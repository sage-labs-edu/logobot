/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/error.ts":
/*!***************************!*\
  !*** ./src/core/error.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogoError = void 0;\nclass LogoError extends Error {\n    constructor(message, location) {\n        super(message);\n        this.name = 'LogoError';\n        this.line = location.line;\n        this.column = location.column;\n        // This is necessary for proper error inheritance in TypeScript\n        Object.setPrototypeOf(this, LogoError.prototype);\n    }\n    toString() {\n        return `${this.name} at line ${this.line}, column ${this.column}: ${this.message}`;\n    }\n}\nexports.LogoError = LogoError;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/error.ts?");

/***/ }),

/***/ "./src/core/index.ts":
/*!***************************!*\
  !*** ./src/core/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runLogo = void 0;\nvar logo_runner_1 = __webpack_require__(/*! ./logo-runner */ \"./src/core/logo-runner.ts\");\nObject.defineProperty(exports, \"runLogo\", ({ enumerable: true, get: function () { return logo_runner_1.runLogo; } }));\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/index.ts?");

/***/ }),

/***/ "./src/core/interpreter/interpreter.ts":
/*!*********************************************!*\
  !*** ./src/core/interpreter/interpreter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Interpreter = void 0;\nclass Interpreter {\n    constructor() {\n        this.variables = new Map();\n    }\n    evaluateExpression(expr) {\n        switch (expr.type) {\n            case 'number':\n                return expr.value;\n            case 'variable': {\n                const value = this.variables.get(expr.value);\n                if (value === undefined) {\n                    throw new Error(`Undefined variable: ${expr.value}`);\n                }\n                return value;\n            }\n            case 'binary': {\n                const left = this.evaluateExpression(expr.left);\n                const right = this.evaluateExpression(expr.right);\n                switch (expr.operator) {\n                    case '+': return left + right;\n                    case '-': return left - right;\n                    case '*': return left * right;\n                    case '/': return left / right;\n                    default: throw new Error(`Unknown operator: ${expr.operator}`);\n                }\n            }\n            case 'comparison': {\n                const left = this.evaluateExpression(expr.left);\n                const right = this.evaluateExpression(expr.right);\n                switch (expr.operator) {\n                    case '<': return left < right;\n                    case '>': return left > right;\n                    case '<=': return left <= right;\n                    case '>=': return left >= right;\n                    case '==': return left === right;\n                    case '!=': return left !== right;\n                    default: throw new Error(`Unknown comparison operator: ${expr.operator}`);\n                }\n            }\n            case 'logical': {\n                const left = this.evaluateExpression(expr.left);\n                // Short-circuit evaluation\n                if (expr.operator === 'and' && !left)\n                    return false;\n                if (expr.operator === 'or' && left)\n                    return true;\n                const right = this.evaluateExpression(expr.right);\n                switch (expr.operator) {\n                    case 'and': return left && right;\n                    case 'or': return left || right;\n                    default: throw new Error(`Unknown logical operator: ${expr.operator}`);\n                }\n            }\n            default:\n                throw new Error(`Unknown expression type: ${expr.type}`);\n        }\n    }\n    evaluateRange(range) {\n        const start = Math.floor(this.evaluateExpression(range.start));\n        const end = Math.floor(this.evaluateExpression(range.end));\n        return { start, end };\n    }\n    interpret(command) {\n        switch (command.type) {\n            case 'forward':\n                return [{\n                        type: 'move',\n                        value: this.evaluateExpression(command.distance)\n                    }];\n            case 'backward':\n                return [{\n                        type: 'move',\n                        value: -this.evaluateExpression(command.distance)\n                    }];\n            case 'turn':\n                return [{\n                        type: 'turn',\n                        value: this.evaluateExpression(command.angle)\n                    }];\n            case 'leftTurn':\n                return [{\n                        type: 'turn',\n                        value: -this.evaluateExpression(command.angle)\n                    }];\n            case 'setPenColor':\n                return [{ type: 'setPenColor', value: command.color }];\n            case 'setPenThickness':\n                return [{\n                        type: 'setPenThickness',\n                        value: this.evaluateExpression(command.thickness)\n                    }];\n            case 'setPenOpacity':\n                return [{\n                        type: 'setPenOpacity',\n                        value: this.evaluateExpression(command.opacity)\n                    }];\n            case 'setPenStyle':\n                return [{ type: 'setPenStyle', value: command.style }];\n            case 'setPenCap':\n                return [{ type: 'setPenCap', value: command.cap }];\n            case 'penUp':\n                return [{ type: 'penUp' }];\n            case 'penDown':\n                return [{ type: 'penDown' }];\n            case 'repeat': {\n                const count = Math.floor(this.evaluateExpression(command.count));\n                const results = [];\n                for (let i = 0; i < count; i++) {\n                    for (const cmd of command.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                return results;\n            }\n            case 'while': {\n                const results = [];\n                let iterationCount = 0;\n                const MAX_ITERATIONS = 100;\n                while (this.evaluateExpression(command.condition)) {\n                    if (iterationCount++ > MAX_ITERATIONS) {\n                        throw new Error('Maximum while loop iterations exceeded');\n                    }\n                    for (const cmd of command.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                return results;\n            }\n            case 'if': {\n                const results = [];\n                if (this.evaluateExpression(command.mainBranch.condition)) {\n                    for (const cmd of command.mainBranch.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                else {\n                    let executed = false;\n                    for (const elifBranch of command.elifBranches) {\n                        if (this.evaluateExpression(elifBranch.condition)) {\n                            for (const cmd of elifBranch.body) {\n                                results.push(...this.interpret(cmd));\n                            }\n                            executed = true;\n                            break;\n                        }\n                    }\n                    if (!executed && command.elseBranch) {\n                        for (const cmd of command.elseBranch) {\n                            results.push(...this.interpret(cmd));\n                        }\n                    }\n                }\n                return results;\n            }\n            case 'for': {\n                const range = this.evaluateRange(command.range);\n                const results = [];\n                // Store original value of loop variable if it exists\n                const originalValue = this.variables.get(command.variable);\n                // Execute loop\n                for (let i = range.start; i <= range.end; i++) {\n                    // Set loop variable\n                    this.variables.set(command.variable, i);\n                    // Execute body\n                    for (const cmd of command.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                // Restore original value or delete if it didn't exist\n                if (originalValue !== undefined) {\n                    this.variables.set(command.variable, originalValue);\n                }\n                else {\n                    this.variables.delete(command.variable);\n                }\n                return results;\n            }\n            case 'assignment': {\n                const value = this.evaluateExpression(command.value);\n                this.variables.set(command.name, value);\n                return [];\n            }\n            default:\n                return [];\n        }\n    }\n}\nexports.Interpreter = Interpreter;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/interpreter/interpreter.ts?");

/***/ }),

/***/ "./src/core/lexer/lexer.ts":
/*!*********************************!*\
  !*** ./src/core/lexer/lexer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Lexer = void 0;\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/core/error.ts\");\nclass Lexer {\n    constructor(source) {\n        this.source = source;\n        this.current = 0;\n        this.start = 0;\n        this.line = 1;\n        this.column = 1;\n        this.tokens = [];\n        // Add new keywords\n        this.keywords = {\n            'fw': 'identifier',\n            'bw': 'identifier',\n            'rt': 'identifier',\n            'lt': 'identifier',\n            'pen': 'identifier',\n            'repeat': 'repeat',\n            'while': 'while',\n            'if': 'if',\n            'elif': 'elif',\n            'else': 'else',\n            'for': 'for',\n            'in': 'in',\n            'and': 'and',\n            'or': 'or',\n            'end': 'end'\n        };\n    }\n    tokenize() {\n        while (!this.isAtEnd()) {\n            this.start = this.current;\n            this.scanToken();\n        }\n        this.tokens.push({\n            type: 'eof',\n            lexeme: '',\n            line: this.line,\n            column: this.column\n        });\n        console.log('All tokens:', JSON.stringify(this.tokens, null, 2));\n        return this.tokens;\n    }\n    scanToken() {\n        const char = this.advance();\n        switch (char) {\n            // Existing single-character tokens\n            case '(':\n                this.addToken('leftParen');\n                break;\n            case ')':\n                this.addToken('rightParen');\n                break;\n            case '.':\n                this.addToken('dot');\n                break;\n            case '+':\n                this.addToken('plus');\n                break;\n            case '-':\n                this.addToken('minus');\n                break;\n            case '*':\n                this.addToken('multiply');\n                break;\n            case '/':\n                this.addToken('divide');\n                break;\n            case ':':\n                this.addToken('colon');\n                break;\n            case '[':\n                this.addToken('leftBracket');\n                break;\n            case ']':\n                this.addToken('rightBracket');\n                break;\n            case '\\n':\n                this.addToken('newline');\n                this.line++;\n                this.column = 1;\n                break;\n            // Two-character comparison operators\n            case '=':\n                if (this.match('=')) {\n                    this.addToken('equal'); // == for comparison\n                }\n                else {\n                    this.addToken('equal'); // = for assignment\n                }\n                break;\n            case '!':\n                if (this.match('=')) {\n                    this.addToken('notEqual');\n                }\n                else {\n                    throw new error_1.LogoError(`Unexpected character: '${char}'`, { line: this.line, column: this.column });\n                }\n                break;\n            case '<':\n                this.addToken(this.match('=') ? 'lessEqual' : 'lessThan');\n                break;\n            case '>':\n                this.addToken(this.match('=') ? 'greaterEqual' : 'greaterThan');\n                break;\n            // Whitespace\n            case ' ':\n            case '\\r':\n            case '\\t':\n                this.column++;\n                break;\n            // String literals\n            case '\"':\n                this.string('\"');\n                break;\n            case \"'\":\n                this.string(\"'\");\n                break;\n            default:\n                if (this.isDigit(char)) {\n                    this.number();\n                }\n                else if (this.isAlpha(char)) {\n                    this.identifier();\n                }\n                else {\n                    throw new error_1.LogoError(`Unexpected character: '${char}'`, { line: this.line, column: this.column });\n                }\n                break;\n        }\n    }\n    identifier() {\n        while (this.isAlphaNumeric(this.peek())) {\n            this.advance();\n        }\n        const text = this.source.substring(this.start, this.current);\n        const type = this.keywords[text] || 'identifier';\n        console.log('Found identifier:', text, 'type:', type);\n        this.addToken(type);\n    }\n    string(quote) {\n        while (this.peek() !== quote && !this.isAtEnd()) {\n            if (this.peek() === '\\n')\n                this.line++;\n            this.advance();\n        }\n        if (this.isAtEnd()) {\n            throw new Error('Unterminated string');\n        }\n        this.advance(); // The closing quote\n        // Get the string value without the quotes\n        const value = this.source.substring(this.start + 1, this.current - 1);\n        this.addToken('string', value);\n    }\n    number() {\n        while (this.isDigit(this.peek()))\n            this.advance();\n        // Look for decimal part\n        if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n            this.advance(); // Consume the .\n            while (this.isDigit(this.peek()))\n                this.advance();\n        }\n        const value = parseFloat(this.source.substring(this.start, this.current));\n        this.addToken('number', value);\n    }\n    isAtEnd() {\n        return this.current >= this.source.length;\n    }\n    advance() {\n        this.column++;\n        return this.source[this.current++];\n    }\n    peek() {\n        if (this.isAtEnd())\n            return '\\0';\n        return this.source[this.current];\n    }\n    peekNext() {\n        if (this.current + 1 >= this.source.length)\n            return '\\0';\n        return this.source[this.current + 1];\n    }\n    isDigit(char) {\n        return char >= '0' && char <= '9';\n    }\n    isAlpha(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            char === '_';\n    }\n    isAlphaNumeric(char) {\n        return this.isAlpha(char) || this.isDigit(char);\n    }\n    addToken(type, literal) {\n        const text = this.source.substring(this.start, this.current);\n        this.tokens.push({\n            type,\n            lexeme: text,\n            literal: literal !== undefined ? literal : text,\n            line: this.line,\n            column: this.column\n        });\n        this.column += this.current - this.start;\n    }\n    makeToken(type, lexeme = '', literal) {\n        return {\n            type,\n            lexeme,\n            literal,\n            line: this.line,\n            column: this.column\n        };\n    }\n    match(expected) {\n        if (this.isAtEnd())\n            return false;\n        if (this.source[this.current] !== expected)\n            return false;\n        this.current++;\n        this.column++;\n        return true;\n    }\n}\nexports.Lexer = Lexer;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/lexer/lexer.ts?");

/***/ }),

/***/ "./src/core/logo-runner.ts":
/*!*********************************!*\
  !*** ./src/core/logo-runner.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runLogo = void 0;\nconst lexer_1 = __webpack_require__(/*! ./lexer/lexer */ \"./src/core/lexer/lexer.ts\");\nconst parser_1 = __webpack_require__(/*! ./parser/parser */ \"./src/core/parser/parser.ts\");\nconst interpreter_1 = __webpack_require__(/*! ./interpreter/interpreter */ \"./src/core/interpreter/interpreter.ts\");\nfunction runLogo(source) {\n    const lexer = new lexer_1.Lexer(source);\n    const tokens = lexer.tokenize();\n    // Debug logging\n    console.log('Tokens:', tokens);\n    const parser = new parser_1.Parser(tokens);\n    const ast = parser.parse();\n    // Debug logging\n    console.log('AST:', JSON.stringify(ast, null, 2));\n    const interpreter = new interpreter_1.Interpreter();\n    const results = [];\n    // Interpret each command in the AST\n    for (const command of ast) {\n        results.push(...interpreter.interpret(command));\n    }\n    return results;\n}\nexports.runLogo = runLogo;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/logo-runner.ts?");

/***/ }),

/***/ "./src/core/parser/parser.ts":
/*!***********************************!*\
  !*** ./src/core/parser/parser.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/core/error.ts\");\nclass Parser {\n    constructor(tokens) {\n        this.tokens = tokens;\n        this.current = 0;\n    }\n    parse() {\n        const commands = [];\n        while (!this.isAtEnd()) {\n            this.skipNewlines();\n            if (this.isAtEnd())\n                break;\n            try {\n                const command = this.parseCommand();\n                commands.push(command);\n            }\n            catch (e) {\n                console.error('Error while parsing:', e);\n                console.log('Current token:', this.peek());\n                console.log('Previous token:', this.previous());\n                throw e;\n            }\n        }\n        return commands;\n    }\n    parseCommand() {\n        this.skipNewlines();\n        const token = this.peek();\n        console.log('Parsing command, token:', token);\n        if (token.type === 'for') {\n            console.log('Found for loop');\n            this.advance();\n            return this.parseFor();\n        }\n        if (token.type === 'identifier') {\n            this.advance();\n            if (this.check('equal')) {\n                const name = token.lexeme;\n                if (this.isKeyword(name)) {\n                    throw new error_1.LogoError(`Cannot use keyword '${name}' as a variable name`, { line: token.line, column: token.column });\n                }\n                this.advance(); // consume the '='\n                const value = this.parseExpression();\n                return {\n                    type: 'assignment',\n                    name,\n                    value\n                };\n            }\n            switch (token.lexeme) {\n                case 'fw': return this.parseForward();\n                case 'bw': return this.parseBackward();\n                case 'rt': return this.parseTurn();\n                case 'lt': return this.parseLeftTurn();\n                case 'pen': return this.parsePenCommand();\n                default:\n                    throw new Error('Unknown command');\n            }\n        }\n        else if (token.type === 'repeat') {\n            this.advance();\n            return this.parseRepeat();\n        }\n        else if (token.type === 'while') {\n            this.advance();\n            return this.parseWhile();\n        }\n        else if (token.type === 'if') {\n            this.advance();\n            return this.parseIf();\n        }\n        else if (token.type === 'end' || token.type === 'elif' || token.type === 'else') {\n            // These tokens should be handled by their respective block parsers\n            throw new Error(`Unexpected ${token.type} token outside of a block`);\n        }\n        throw new Error(`Expected command, got ${token.type} (${token.lexeme})`);\n    }\n    skipNewlines() {\n        while (this.check('newline')) {\n            this.advance();\n        }\n    }\n    parsePenCommand() {\n        if (!this.check('dot')) {\n            throw new Error(\"Expected '.' after 'pen'\");\n        }\n        this.advance();\n        const prop = this.consume('identifier', 'Expected property name');\n        if (prop.lexeme === 'up') {\n            this.consume('leftParen', \"Expected '('\");\n            this.consume('rightParen', \"Expected ')'\");\n            return { type: 'penUp' };\n        }\n        if (prop.lexeme === 'down') {\n            this.consume('leftParen', \"Expected '('\");\n            this.consume('rightParen', \"Expected ')'\");\n            return { type: 'penDown' };\n        }\n        this.consume('equal', \"Expected '='\");\n        switch (prop.lexeme) {\n            case 'color': {\n                const color = this.consume('string', 'Expected color string');\n                return { type: 'setPenColor', color: color.literal };\n            }\n            case 'thickness': {\n                const thickness = this.parseExpression();\n                return { type: 'setPenThickness', thickness };\n            }\n            case 'opacity': {\n                const opacity = this.parseExpression();\n                if (this.previous().type === 'number') {\n                    const value = this.previous().literal;\n                    if (value < 0 || value > 1) {\n                        throw new error_1.LogoError('Opacity must be between 0 and 1', {\n                            line: this.previous().line,\n                            column: this.previous().column\n                        });\n                    }\n                }\n                return { type: 'setPenOpacity', opacity };\n            }\n            case 'style': {\n                const style = this.consume('string', 'Expected style string');\n                if (!['line', 'dash', 'dot'].includes(style.literal)) {\n                    throw new Error('Invalid pen style');\n                }\n                return { type: 'setPenStyle', style: style.literal };\n            }\n            case 'cap': {\n                const cap = this.consume('string', 'Expected cap string');\n                if (!['round', 'butt', 'square'].includes(cap.literal)) {\n                    throw new Error('Invalid pen cap style');\n                }\n                return { type: 'setPenCap', cap: cap.literal };\n            }\n            default:\n                throw new Error('Unknown pen property');\n        }\n    }\n    parseForward() {\n        this.consume('leftParen', \"Expected '(' after fw\");\n        const distance = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'forward',\n            distance: distance\n        };\n    }\n    parseBackward() {\n        this.consume('leftParen', \"Expected '(' after bw\");\n        const distance = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'backward',\n            distance: distance\n        };\n    }\n    parseTurn() {\n        this.consume('leftParen', \"Expected '(' after rt\");\n        const angle = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'turn',\n            angle: angle\n        };\n    }\n    parseLeftTurn() {\n        this.consume('leftParen', \"Expected '(' after lt\");\n        const angle = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'leftTurn',\n            angle: angle\n        };\n    }\n    parseRepeat() {\n        const count = this.parseExpression();\n        this.consume('colon', \"Expected ':' after repeat count\");\n        this.skipNewlines();\n        const body = [];\n        while (!this.check('end') && !this.isAtEnd()) {\n            this.skipNewlines();\n            if (!this.check('end')) {\n                body.push(this.parseCommand());\n            }\n        }\n        this.consume('end', \"Expected 'end' after repeat block\");\n        return { type: 'repeat', count, body };\n    }\n    parseWhile() {\n        const condition = this.parseExpression();\n        this.consume('colon', \"Expected ':' after while condition\");\n        this.skipNewlines();\n        const body = [];\n        while (!this.check('end') && !this.isAtEnd()) {\n            this.skipNewlines();\n            if (!this.check('end')) {\n                body.push(this.parseCommand());\n            }\n        }\n        this.consume('end', \"Expected 'end' after while block\");\n        return { type: 'while', condition, body };\n    }\n    parseExpression() {\n        let expr = this.parseLogicalOr();\n        if (this.match('notEqual', 'equal', 'lessThan', 'greaterThan', 'lessEqual', 'greaterEqual')) {\n            const operator = this.operatorFromToken(this.previous().type);\n            const right = this.parseLogicalOr();\n            expr = {\n                type: 'comparison',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseLogicalOr() {\n        let expr = this.parseLogicalAnd();\n        while (this.match('or')) {\n            const operator = 'or';\n            const right = this.parseLogicalAnd();\n            expr = {\n                type: 'logical',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseLogicalAnd() {\n        let expr = this.parseComparison();\n        while (this.match('and')) {\n            const operator = 'and';\n            const right = this.parseComparison();\n            expr = {\n                type: 'logical',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseComparison() {\n        let expr = this.parseAdditive();\n        while (this.match('notEqual', 'equal', 'lessThan', 'greaterThan', 'lessEqual', 'greaterEqual')) {\n            const operator = this.operatorFromToken(this.previous().type);\n            const right = this.parseAdditive();\n            expr = {\n                type: 'comparison',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseAdditive() {\n        let expr = this.parseMultiplicative();\n        while (this.match('plus', 'minus')) {\n            const operator = this.previous().type === 'plus' ? '+' : '-';\n            const right = this.parseMultiplicative();\n            expr = {\n                type: 'binary',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseMultiplicative() {\n        let expr = this.parsePrimary();\n        while (this.match('multiply', 'divide')) {\n            const operator = this.previous().type === 'multiply' ? '*' : '/';\n            const right = this.parsePrimary();\n            expr = {\n                type: 'binary',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parsePrimary() {\n        if (this.match('number')) {\n            return {\n                type: 'number',\n                value: this.previous().literal\n            };\n        }\n        if (this.match('identifier')) {\n            return {\n                type: 'variable',\n                value: this.previous().lexeme\n            };\n        }\n        if (this.match('leftParen')) {\n            const expr = this.parseExpression();\n            this.consume('rightParen', \"Expected ')' after expression\");\n            return expr;\n        }\n        throw new error_1.LogoError('Expected expression', {\n            line: this.peek().line,\n            column: this.peek().column\n        });\n    }\n    operatorFromToken(type) {\n        switch (type) {\n            case 'notEqual': return '!=';\n            case 'equal': return '==';\n            case 'lessThan': return '<';\n            case 'greaterThan': return '>';\n            case 'lessEqual': return '<=';\n            case 'greaterEqual': return '>=';\n            default: return type;\n        }\n    }\n    consume(type, message) {\n        if (this.check(type)) {\n            return this.advance();\n        }\n        throw new Error(message);\n    }\n    check(type) {\n        if (this.isAtEnd())\n            return false;\n        return this.peek().type === type;\n    }\n    advance() {\n        if (!this.isAtEnd())\n            this.current++;\n        return this.previous();\n    }\n    isAtEnd() {\n        return this.current >= this.tokens.length || this.peek().type === 'eof';\n    }\n    peek() {\n        return this.tokens[this.current];\n    }\n    previous() {\n        return this.tokens[this.current - 1];\n    }\n    match(...types) {\n        for (const type of types) {\n            if (this.check(type)) {\n                this.advance();\n                return true;\n            }\n        }\n        return false;\n    }\n    parseIf() {\n        const mainBranch = this.parseConditionalBranch();\n        const elifBranches = [];\n        let elseBranch = undefined;\n        while (this.match('elif')) {\n            elifBranches.push(this.parseConditionalBranch());\n        }\n        if (this.match('else')) {\n            this.consume('colon', \"Expected ':' after else\");\n            this.skipNewlines();\n            elseBranch = this.parseBlock();\n        }\n        this.consume('end', \"Expected 'end' after if block\");\n        return { type: 'if', mainBranch, elifBranches, elseBranch };\n    }\n    parseConditionalBranch() {\n        const condition = this.parseExpression();\n        console.log('After parsing expression, current token:', this.peek()); // Updated debug\n        this.consume('colon', \"Expected ':' after condition\");\n        this.skipNewlines();\n        const body = this.parseBlock();\n        return { condition, body };\n    }\n    parseBlock() {\n        const commands = [];\n        while (!this.check('end') && !this.check('elif') && !this.check('else') && !this.isAtEnd()) {\n            if (this.check('newline')) {\n                this.advance(); // Skip newlines between commands\n                continue;\n            }\n            commands.push(this.parseCommand());\n        }\n        return commands;\n    }\n    parseFor() {\n        console.log('Parsing for loop, current token:', this.peek());\n        const variable = this.consume('identifier', \"Expected loop variable\").lexeme;\n        console.log('Got variable:', variable);\n        this.consume('in', \"Expected 'in' after loop variable\");\n        this.consume('leftBracket', \"Expected '[' to start range\");\n        const start = this.parseExpression();\n        this.consume('colon', \"Expected ':' in range\");\n        const end = this.parseExpression();\n        this.consume('rightBracket', \"Expected ']' to end range\");\n        this.consume('colon', \"Expected ':' after range\");\n        this.skipNewlines();\n        const body = this.parseBlock();\n        this.consume('end', \"Expected 'end' after for block\");\n        return {\n            type: 'for',\n            variable,\n            range: { type: 'range', start, end },\n            body\n        };\n    }\n    isKeyword(name) {\n        return [\n            'for', 'in', 'end', 'if', 'else', 'elif',\n            'while', 'repeat', 'and', 'or'\n        ].includes(name);\n    }\n}\nexports.Parser = Parser;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/parser/parser.ts?");

/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TurtleRenderer = void 0;\n// Centralized default pen options\nconst defaultPenOptions = {\n    color: '#00cecb',\n    thickness: 2,\n    style: 'line',\n    cap: 'round',\n    opacity: 1,\n    dashArray: ''\n};\nclass TurtleRenderer {\n    constructor(container, defaultSize = 800, pointerOptions, penOptions) {\n        this.container = container;\n        this.defaultSize = defaultSize;\n        this.x = 0;\n        this.y = 0;\n        this.angle = -90;\n        this.penDown = true;\n        this.statusBar = null;\n        // Get container size or use default\n        const rect = container.getBoundingClientRect();\n        this.width = rect.width || defaultSize;\n        this.height = rect.height || defaultSize;\n        // Initialize pen and pointer options\n        this.pointerOptions = {\n            size: 10,\n            color: '#ff69b4',\n            anchorPoint: [0, -0.5],\n            ...pointerOptions\n        };\n        this.penOptions = { ...defaultPenOptions, ...penOptions };\n        // Check if an SVG already exists\n        let existingSvg = container.querySelector('svg');\n        if (existingSvg) {\n            this.svg = existingSvg;\n            this.linesGroup = this.svg.querySelector('g:first-child');\n            this.turtleGroup = this.svg.querySelector('g:last-child');\n        }\n        else {\n            // Create new SVG and groups if none exist\n            this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            this.svg.setAttribute('width', '100%');\n            this.svg.setAttribute('height', '100%');\n            this.svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n            this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n            this.linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            this.turtleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            this.svg.appendChild(this.linesGroup);\n            this.svg.appendChild(this.turtleGroup);\n            container.appendChild(this.svg);\n        }\n        // Check if status bar exists\n        let existingStatus = container.querySelector('.turtle-status');\n        if (!existingStatus && defaultSize === 800) {\n            this.statusBar = document.createElement('div');\n            this.statusBar.className = 'turtle-status';\n            container.appendChild(this.statusBar);\n        }\n        else if (existingStatus) {\n            this.statusBar = existingStatus;\n        }\n        this.reset();\n    }\n    createTurtlePointer() {\n        const { size, color, anchorPoint } = this.pointerOptions;\n        const ax = anchorPoint[0] * size;\n        const ay = anchorPoint[1] * size;\n        const points = [\n            [-size / 2 - ax, -size / 2 - ay],\n            [size / 2 - ax, -size / 2 - ay],\n            [0 - ax, size - ay]\n        ].map(([x, y]) => `${x},${y}`).join(' ');\n        const pointer = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n        pointer.setAttribute('points', points);\n        pointer.setAttribute('fill', color);\n        pointer.setAttribute('transform', 'rotate(-90)');\n        this.turtleGroup.appendChild(pointer);\n        this.updateTurtleTransform();\n    }\n    updateTurtleTransform() {\n        this.turtleGroup.setAttribute('transform', `translate(${this.x} ${this.y}) rotate(${this.angle})`);\n        if (this.statusBar) {\n            const centerX = this.width / 2;\n            const centerY = this.height / 2;\n            const dx = Math.round(this.x - centerX);\n            const dy = Math.round(centerY - this.y);\n            let angle = (this.angle + 90) % 360;\n            if (angle < 0)\n                angle += 360;\n            this.statusBar.textContent =\n                `Angle: ${angle.toFixed(1)}° | X: ${dx} | Y: ${dy}`;\n        }\n    }\n    move(distance) {\n        const radians = (this.angle * Math.PI) / 180;\n        const newX = this.x + distance * Math.cos(radians);\n        const newY = this.y + distance * Math.sin(radians);\n        if (this.penDown) {\n            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n            line.setAttribute('x1', this.x.toString());\n            line.setAttribute('y1', this.y.toString());\n            line.setAttribute('x2', newX.toString());\n            line.setAttribute('y2', newY.toString());\n            line.setAttribute('stroke', this.penOptions.color);\n            line.setAttribute('stroke-width', this.penOptions.thickness.toString());\n            line.setAttribute('stroke-linecap', this.penOptions.cap);\n            line.setAttribute('opacity', this.penOptions.opacity.toString());\n            if (this.penOptions.dashArray) {\n                line.setAttribute('stroke-dasharray', this.penOptions.dashArray);\n            }\n            this.linesGroup.appendChild(line);\n        }\n        this.x = newX;\n        this.y = newY;\n        this.updateTurtleTransform();\n    }\n    turn(degrees) {\n        this.angle = (this.angle + degrees) % 360;\n        if (this.angle < 0) {\n            this.angle += 360;\n        }\n        this.updateTurtleTransform();\n    }\n    executeCommands(commands) {\n        this.clear();\n        for (const cmd of commands) {\n            switch (cmd.type) {\n                case 'move':\n                    this.move(cmd.value);\n                    break;\n                case 'turn':\n                    this.turn(cmd.value);\n                    break;\n                case 'setPenColor':\n                    this.penOptions.color = cmd.value;\n                    break;\n                case 'setPenThickness':\n                    this.penOptions.thickness = cmd.value;\n                    break;\n                case 'setPenOpacity':\n                    this.penOptions.opacity = cmd.value;\n                    break;\n                case 'setPenStyle':\n                    this.penOptions.style = cmd.value;\n                    // Apply dash array based on style\n                    if (cmd.value === 'dash') {\n                        this.penOptions.dashArray = '10,5';\n                    }\n                    else if (cmd.value === 'dot') {\n                        this.penOptions.dashArray = '2,2';\n                    }\n                    else {\n                        this.penOptions.dashArray = '';\n                    }\n                    break;\n                case 'setPenCap':\n                    this.penOptions.cap = cmd.value;\n                    break;\n                case 'penUp':\n                    this.penDown = false;\n                    break;\n                case 'penDown':\n                    this.penDown = true;\n                    break;\n            }\n        }\n    }\n    clear() {\n        // Remove any existing SVGs except the current one\n        const svgs = this.container.querySelectorAll('svg');\n        svgs.forEach(svg => {\n            if (svg !== this.svg) {\n                svg.remove();\n            }\n        });\n        // Clear the lines\n        while (this.linesGroup.firstChild) {\n            this.linesGroup.removeChild(this.linesGroup.firstChild);\n        }\n        this.reset();\n    }\n    reset() {\n        this.x = this.width / 2;\n        this.y = this.height / 2;\n        this.angle = -90;\n        this.penDown = true;\n        // Reset pen options to default\n        this.penOptions = { ...defaultPenOptions };\n        while (this.turtleGroup.firstChild) {\n            this.turtleGroup.removeChild(this.turtleGroup.firstChild);\n        }\n        this.createTurtlePointer();\n    }\n    // Method to update pointer options\n    updatePointerOptions(options) {\n        this.pointerOptions = {\n            ...this.pointerOptions,\n            ...options\n        };\n        // Recreate pointer with new options\n        while (this.turtleGroup.firstChild) {\n            this.turtleGroup.removeChild(this.turtleGroup.firstChild);\n        }\n        this.createTurtlePointer();\n    }\n}\nexports.TurtleRenderer = TurtleRenderer;\n\n\n//# sourceURL=webpack://logobot-v3/./src/renderer.ts?");

/***/ }),

/***/ "./src/test-visual.ts":
/*!****************************!*\
  !*** ./src/test-visual.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconsole.log('Test visual script loading...');\nconst core_1 = __webpack_require__(/*! ./core */ \"./src/core/index.ts\");\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \"./src/renderer.ts\");\n// Add after imports\nconsole.log('Imports completed');\nconst tests = [\n    {\n        name: 'Default Line',\n        code: 'fw(50)',\n        expected: 'Should draw a line with default settings (#00cecb, 2px, round cap)'\n    },\n    {\n        name: 'Custom Color',\n        code: 'pen.color = \"red\"\\nfw(50)',\n        expected: 'Should draw a red line'\n    },\n    {\n        name: 'Custom Thickness',\n        code: 'pen.thickness = 5\\nfw(50)',\n        expected: 'Should draw a thick line (5px)'\n    },\n    {\n        name: 'Dashed Line',\n        code: 'pen.style = \"dash\"\\nfw(50)',\n        expected: 'Should draw a dashed line'\n    },\n    {\n        name: 'Dotted Line',\n        code: 'pen.style = \"dot\"\\nfw(50)',\n        expected: 'Should draw a dotted line'\n    },\n    {\n        name: 'Square Cap',\n        code: 'pen.thickness = 10\\npen.cap = \"square\"\\nfw(50)',\n        expected: 'Should draw a thick line with square ends'\n    },\n    {\n        name: 'Butt Cap',\n        code: 'pen.thickness = 10\\npen.cap = \"butt\"\\nfw(50)',\n        expected: 'Should draw a thick line with flat ends'\n    },\n    {\n        name: 'Semi-transparent',\n        code: 'pen.opacity = 0.5\\nfw(50)',\n        expected: 'Should draw a semi-transparent line'\n    },\n    {\n        name: 'Combined Styles',\n        code: 'pen.color = \"#ff69b4\"\\npen.thickness = 8\\npen.style = \"dash\"\\npen.opacity = 0.7\\nfw(50)',\n        expected: 'Should draw a thick, semi-transparent, dashed pink line'\n    },\n    {\n        name: 'Square',\n        code: 'fw(50)\\nrt(90)\\nfw(50)\\nrt(90)\\nfw(50)\\nrt(90)\\nfw(50)',\n        expected: 'Should draw a square with default pen settings'\n    },\n    {\n        name: 'Styled Square',\n        code: 'pen.color = \"purple\"\\npen.thickness = 3\\npen.style = \"dash\"\\nfw(50)\\nrt(90)\\nfw(50)\\nrt(90)\\nfw(50)\\nrt(90)\\nfw(50)',\n        expected: 'Should draw a purple dashed square'\n    },\n    {\n        name: 'Repeat 3 times',\n        code: 'repeat 3: fw(20) rt(45) end',\n        expected: 'Should draw 3 lines with 45° turns'\n    },\n    {\n        name: 'Variable Repeat',\n        code: 'x = 3 repeat x: fw(x) rt(45+x) end',\n        expected: 'Should use variable x in repeat'\n    },\n    {\n        name: 'Nested Repeat',\n        code: `\n          repeat 3:\n            pen.color = 'blue'\n            fw(20)\n            rt(45)\n            repeat 5:\n              pen.color = 'red'\n              fw(30)\n              lt(65)\n            end\n          end\n        `,\n        expected: 'Should draw nested repeat patterns'\n    },\n    {\n        name: 'Simple While Loop',\n        code: `\n          x = 0\n          while x < 4:\n            fw(50)\n            rt(90)\n            x = x + 1\n          end\n        `,\n        expected: 'Should draw a square using while loop'\n    },\n    {\n        name: 'While with Multiple Variables',\n        code: `\n          x = 20\n          y = 90\n          while x < 100:\n            fw(x)\n            rt(y)\n            x = x + 20\n            y = y - 15\n          end\n        `,\n        expected: 'Should draw an expanding spiral'\n    },\n    {\n        name: 'While with Complex Condition',\n        code: `\n          x = 2\n          y = 3\n          z = 13\n          while ((x < y) and (y < z)) or z > 10:\n            pen.color = 'blue'\n            fw(100)\n            rt(35)\n            z = z - 2\n            pen.color = 'red'\n            fw(50)\n            lt(20)\n          end\n        `,\n        expected: 'Should draw a complex pattern with color changes'\n    },\n    {\n        name: 'Nested While Loops',\n        code: `\n          x = 0\n          while x < 3:\n            y = 0\n            while y < 4:\n              fw(30)\n              rt(90)\n              y = y + 1\n            end\n            lt(120)\n            x = x + 1\n          end\n        `,\n        expected: 'Should draw three squares arranged in a triangle'\n    },\n    {\n        name: 'Repeat inside While',\n        code: `\n          x = 0\n          while x < 2:\n            repeat 3:\n              fw(20)\n              rt(60)\n            end\n            x = x + 1\n          end\n        `,\n        expected: 'Should draw two sets of three lines forming triangles'\n    },\n    {\n        name: 'While inside Repeat',\n        code: `\n          repeat 2:\n            y = 0\n            while y < 3:\n              fw(30)\n              rt(90)\n              y = y + 1\n            end\n            lt(120)\n          end\n        `,\n        expected: 'Should draw two squares with a 120-degree turn between them'\n    },\n    {\n        name: 'Nested While and Repeat',\n        code: `\n          x = 0\n          while x < 2:\n            repeat 2:\n              y = 0\n              while y < 2:\n                fw(20)\n                rt(45)\n                y = y + 1\n              end\n              lt(90)\n            end\n            x = x + 1\n          end\n        `,\n        expected: 'Should draw a complex pattern with nested loops'\n    },\n    {\n        name: 'Basic If/Else',\n        code: `\n          x = 3\n          y = 4\n          if x != y:\n            pen.color = 'blue'\n            fw(30)\n          elif x == 5:\n            pen.color = 'green'\n            bw(30)\n          else:\n            pen.color = 'black'\n            fw(30)\n            rt(30)\n          end\n        `,\n        expected: 'Should draw a blue line if x != y'\n    },\n    {\n        name: 'If with Repeat',\n        code: `\n          x = 2\n          if x < 5:\n            repeat 3:\n              fw(20)\n              rt(60)\n            end\n          else:\n            fw(50)\n          end\n        `,\n        expected: 'Should draw a triangle if x < 5'\n    },\n    {\n        name: 'If with While',\n        code: `\n          x = 0\n          if x == 0:\n            while x < 3:\n              fw(20)\n              rt(90)\n              x = x + 1\n            end\n          else:\n            fw(50)\n          end\n        `,\n        expected: 'Should draw a square if x == 0'\n    },\n    {\n        name: 'Complex Nested Conditions',\n        code: `\n          x = 1\n          y = 2\n          if x < y:\n            repeat 2:\n              if y > 1:\n                fw(20)\n                rt(45)\n              else:\n                fw(10)\n              end\n            end\n          else:\n            while x < 3:\n              fw(30)\n              rt(90)\n              x = x + 1\n            end\n          end\n        `,\n        expected: 'Should draw a pattern based on nested conditions'\n    },\n    {\n        name: 'Simple For Loop',\n        code: `\n          for i in [1:4]:\n            fw(30)\n            rt(90)\n          end\n        `,\n        expected: 'Should draw a square using for loop'\n    },\n    {\n        name: 'Variable Range For Loop',\n        code: `\n          startVal = 1\n          endVal = 5\n          for i in [startVal:endVal]:\n            pen.color = 'blue'\n            fw(i * 20)\n            rt(72)\n          end\n        `,\n        expected: 'Should draw an expanding spiral with increasing line lengths'\n    },\n    {\n        name: 'Nested For Loops',\n        code: `\n          for i in [1:3]:\n            pen.color = 'red'\n            for j in [1:2]:\n              fw(i * 20)\n              rt(j * 60)\n            end\n            pen.color = 'blue'\n            fw(10)\n          end\n        `,\n        expected: 'Should draw a complex pattern with nested loops and color changes'\n    },\n    {\n        name: 'For Loop with Conditions',\n        code: `\n          for i in [1:5]:\n            if i > 2:\n              pen.color = 'green'\n              fw(i * 15)\n            else:\n              pen.color = 'red'\n              fw(10)\n            end\n            rt(72)\n          end\n        `,\n        expected: 'Should draw a pattern with different colors based on loop index'\n    },\n    {\n        name: 'For Loop with Multiple Controls',\n        code: `\n          for i in [1:3]:\n            repeat i:\n              fw(30)\n              rt(120)\n            end\n            while i < 3:\n              fw(20)\n              rt(45)\n              i = i + 1\n            end\n          end\n        `,\n        expected: 'Should draw a complex pattern using multiple control structures'\n    }\n];\n// Get existing container instead of creating new one\nconst container = document.getElementById('test-container');\nconsole.log('Found container:', container);\n// Clear any existing content\ncontainer.innerHTML = '';\n// Add page title\nconst title = document.createElement('h1');\ntitle.textContent = 'Logo Turtle Graphics Test Cases';\ntitle.style.width = '100%';\ntitle.style.textAlign = 'center';\ntitle.style.marginBottom = '20px';\ncontainer.appendChild(title);\n// Style the container\ncontainer.style.display = 'flex';\ncontainer.style.flexWrap = 'wrap';\ncontainer.style.gap = '20px';\ncontainer.style.padding = '20px';\n// Run tests\ntests.forEach(test => {\n    // Create test case container\n    const testCase = document.createElement('div');\n    testCase.style.border = '1px solid #ccc';\n    testCase.style.padding = '15px';\n    testCase.style.width = '250px';\n    testCase.style.borderRadius = '5px';\n    testCase.style.backgroundColor = '#fff';\n    // Add test name\n    const name = document.createElement('h3');\n    name.textContent = test.name;\n    name.style.margin = '0 0 10px 0';\n    testCase.appendChild(name);\n    // Add code display\n    const code = document.createElement('pre');\n    code.textContent = test.code;\n    code.style.backgroundColor = '#f5f5f5';\n    code.style.padding = '10px';\n    code.style.borderRadius = '4px';\n    code.style.overflowX = 'auto';\n    code.style.fontSize = '12px';\n    testCase.appendChild(code);\n    // Add expected behavior\n    const expected = document.createElement('div');\n    expected.textContent = test.expected;\n    expected.style.color = '#666';\n    expected.style.fontSize = '0.9em';\n    expected.style.marginTop = '10px';\n    testCase.appendChild(expected);\n    // Create SVG container\n    const svgContainer = document.createElement('div');\n    svgContainer.style.width = '200px';\n    svgContainer.style.height = '200px';\n    svgContainer.style.border = '1px solid #eee';\n    svgContainer.style.marginTop = '10px';\n    testCase.appendChild(svgContainer);\n    // Run the Logo code\n    const renderer = new renderer_1.TurtleRenderer(svgContainer, 200);\n    const commands = (0, core_1.runLogo)(test.code);\n    renderer.executeCommands(commands);\n    // Add to main container\n    container.appendChild(testCase);\n});\n\n\n//# sourceURL=webpack://logobot-v3/./src/test-visual.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/test-visual.ts");
/******/ 	
/******/ })()
;